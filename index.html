<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SVG to TFT_eSPI Converter</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #1a1a1a;
        color: #e0e0e0;
        padding: 20px;
        line-height: 1.6;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
      }

      .container {
        max-width: 900px;
        width: 100%;
      }

      header {
        text-align: center;
        margin-bottom: 40px;
      }

      h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .subtitle {
        color: #888;
        font-size: 1.1em;
      }

      .panel {
        background: #2a2a2a;
        border-radius: 12px;
        padding: 30px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        margin-bottom: 20px;
      }

      .upload-area {
        border: 3px dashed #444;
        border-radius: 8px;
        padding: 60px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s;
        margin-bottom: 20px;
      }

      .upload-area:hover {
        border-color: #667eea;
        background: #333;
      }

      .upload-area.dragover {
        border-color: #764ba2;
        background: #333;
      }

      .upload-icon {
        font-size: 4em;
        margin-bottom: 15px;
      }

      input[type="file"] {
        display: none;
      }

      textarea {
        width: 100%;
        min-height: 400px;
        background: #1a1a1a;
        border: 1px solid #444;
        border-radius: 8px;
        padding: 20px;
        color: #e0e0e0;
        font-family: "Courier New", monospace;
        font-size: 0.9em;
        resize: vertical;
      }

      .button-group {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      button {
        flex: 1;
        padding: 15px 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1em;
        font-weight: 600;
        transition:
          transform 0.2s,
          box-shadow 0.2s;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      }

      button:active {
        transform: translateY(0);
      }

      .info-box {
        background: #1a3a5a;
        border-left: 4px solid #667eea;
        padding: 15px;
        margin-top: 20px;
        border-radius: 6px;
        font-size: 0.9em;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>SVG to TFT_eSPI Converter</h1>
        <p class="subtitle">
          Convert SVG graphics to Arduino sketches for TFT displays
        </p>
      </header>

      <div class="panel" id="uploadPanel">
        <div class="upload-area" id="uploadArea">
          <div class="upload-icon">ðŸ“¤</div>
          <p style="font-size: 1.3em; margin-bottom: 10px">
            <strong>Drop SVG file here</strong>
          </p>
          <p style="color: #888">or click to browse</p>
          <input type="file" id="fileInput" accept=".svg,image/svg+xml" />
        </div>
      </div>

      <div class="panel hidden" id="outputPanel">
        <textarea id="codeOutput" readonly></textarea>

        <div class="button-group">
          <button onclick="downloadSketch()">ðŸ’¾ Download .ino</button>
          <button onclick="copyCode()">ðŸ“‹ Copy Code</button>
          <button onclick="reset()">ðŸ”„ New SVG</button>
        </div>

        <div class="info-box" id="infoBox">
          <strong>Auto-detected:</strong> Background color, viewport scaling,
          text font sizes
        </div>
      </div>
    </div>

    <script>
      let currentSVG = null;
      let parsedElements = [];
      let gradients = {};
      let svgFileName = "";
      let backgroundColor = "TFT_BLACK";
      let scaleX = 1;
      let scaleY = 1;
      let screenWidth = 0;
      let screenHeight = 0;

      // TFT_eSPI font sizes in pixels (approximate heights)
      const FONT_SIZES = {
        1: 8,
        2: 16,
        4: 26,
        6: 48,
        7: 48,
        8: 75,
      };

      const uploadArea = document.getElementById("uploadArea");
      const fileInput = document.getElementById("fileInput");

      uploadArea.addEventListener("click", () => fileInput.click());

      uploadArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadArea.classList.add("dragover");
      });

      uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("dragover");
      });

      uploadArea.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadArea.classList.remove("dragover");
        const file = e.dataTransfer.files[0];
        if (
          file &&
          (file.type === "image/svg+xml" || file.name.endsWith(".svg"))
        ) {
          loadSVG(file);
        }
      });

      fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file) {
          loadSVG(file);
        }
      });

      function sanitizeName(filename) {
        let name = filename.replace(/\.svg$/i, "");
        name = name.replace(/[^a-zA-Z0-9_]/g, "_");
        name = name.replace(/^_+|_+$/g, "");
        if (name && !/^[a-zA-Z]/.test(name)) {
          name = "svg_" + name;
        }
        return name.charAt(0).toUpperCase() + name.slice(1);
      }

      function loadSVG(file) {
        svgFileName = sanitizeName(file.name);

        const reader = new FileReader();
        reader.onload = (e) => {
          const svgContent = e.target.result;
          processSVG(svgContent);
        };
        reader.readAsText(file);
      }

      function processSVG(svgContent) {
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(svgContent, "image/svg+xml");
        currentSVG = svgDoc.querySelector("svg");

        if (!currentSVG) {
          alert("Invalid SVG file");
          return;
        }

        calculateScaling();
        detectBackgroundColor();
        parseSVGElements();
        generateCode();

        document.getElementById("infoBox").innerHTML = `
                <strong>Auto-detected:</strong> 
                Screen: ${screenWidth}Ã—${screenHeight}px, 
                Scale: ${scaleX.toFixed(2)}x, 
                Background: ${backgroundColor}, 
                ${parsedElements.filter((e) => e.type === "text").length} text elements
            `;

        document.getElementById("uploadPanel").classList.add("hidden");
        document.getElementById("outputPanel").classList.remove("hidden");
      }

      function calculateScaling() {
        const viewportWidth = parseFloat(currentSVG.getAttribute("width")) || 0;
        const viewportHeight =
          parseFloat(currentSVG.getAttribute("height")) || 0;

        const viewBox = currentSVG.getAttribute("viewBox");
        let viewBoxWidth, viewBoxHeight;

        if (viewBox) {
          const parts = viewBox.trim().split(/\s+|,/).map(parseFloat);
          viewBoxWidth = parts[2] || viewportWidth || 100;
          viewBoxHeight = parts[3] || viewportHeight || 100;
        } else {
          viewBoxWidth = viewportWidth || 100;
          viewBoxHeight = viewportHeight || 100;
        }

        if (viewportWidth && viewBoxWidth) {
          scaleX = viewportWidth / viewBoxWidth;
          scaleY = viewportHeight / viewBoxHeight;
          screenWidth = Math.round(viewportWidth);
          screenHeight = Math.round(viewportHeight);
        } else {
          scaleX = 1;
          scaleY = 1;
          screenWidth = Math.round(viewBoxWidth);
          screenHeight = Math.round(viewBoxHeight);
        }
      }

      function scaleCoord(value, axis = "x") {
        const scale = axis === "x" ? scaleX : scaleY;
        return Math.round(value * scale);
      }

      function detectBackgroundColor() {
        let bgColor = null;

        const svgStyle = currentSVG.getAttribute("style");
        if (svgStyle) {
          const bgMatch = svgStyle.match(
            /background(?:-color)?\s*:\s*([^;]+)/i,
          );
          if (bgMatch) {
            bgColor = bgMatch[1].trim();
          }
        }

        const viewBox = currentSVG.getAttribute("viewBox");
        let vbWidth,
          vbHeight,
          vbMinX = 0,
          vbMinY = 0;
        if (viewBox) {
          const parts = viewBox.split(/\s+|,/).map(parseFloat);
          vbMinX = parts[0] || 0;
          vbMinY = parts[1] || 0;
          vbWidth = parts[2];
          vbHeight = parts[3];
        } else {
          vbWidth = parseFloat(currentSVG.getAttribute("width")) || 100;
          vbHeight = parseFloat(currentSVG.getAttribute("height")) || 100;
        }

        const rects = currentSVG.querySelectorAll("rect");
        for (let rect of rects) {
          const x = parseFloat(rect.getAttribute("x") || 0);
          const y = parseFloat(rect.getAttribute("y") || 0);
          const w = parseFloat(rect.getAttribute("width") || 0);
          const h = parseFloat(rect.getAttribute("height") || 0);

          if (
            Math.abs(x - vbMinX) < 0.1 &&
            Math.abs(y - vbMinY) < 0.1 &&
            Math.abs(w - vbWidth) < 0.1 &&
            Math.abs(h - vbHeight) < 0.1
          ) {
            const fill =
              rect.getAttribute("fill") || getStyleValue(rect, "fill");
            if (fill && fill !== "none") {
              bgColor = fill;
              break;
            }
          }
        }

        backgroundColor = bgColor ? colorToRGB565(bgColor) : "TFT_BLACK";
        if (!backgroundColor) {
          backgroundColor = "TFT_BLACK";
        }
      }

      function getClosestFont(pixelSize) {
        let size = pixelSize;
        if (typeof size === "string") {
          size = parseFloat(size.replace(/px|pt|em|rem/gi, ""));
          if (pixelSize.includes("pt")) {
            size *= 1.333;
          }
        }

        size = size * scaleY;

        let closestFont = 2;
        let minDiff = Infinity;

        for (let [font, height] of Object.entries(FONT_SIZES)) {
          const diff = Math.abs(height - size);
          if (diff < minDiff) {
            minDiff = diff;
            closestFont = parseInt(font);
          }
        }

        return closestFont;
      }

      function parseStyleAttribute(styleStr) {
        const styles = {};
        if (!styleStr) return styles;

        const declarations = styleStr.split(";");
        for (let decl of declarations) {
          const [prop, value] = decl.split(":").map((s) => s.trim());
          if (prop && value) {
            styles[prop] = value;
          }
        }
        return styles;
      }

      function getStyleValue(element, attr, defaultValue = null) {
        if (element.hasAttribute(attr)) {
          return element.getAttribute(attr);
        }

        const styleAttr = element.getAttribute("style");
        if (styleAttr) {
          const styles = parseStyleAttribute(styleAttr);
          if (styles[attr]) {
            return styles[attr];
          }
        }

        let parent = element.parentElement;
        while (parent && parent.tagName.toLowerCase() !== "svg") {
          if (parent.hasAttribute(attr)) {
            return parent.getAttribute(attr);
          }

          const parentStyle = parent.getAttribute("style");
          if (parentStyle) {
            const styles = parseStyleAttribute(parentStyle);
            if (styles[attr]) {
              return styles[attr];
            }
          }

          parent = parent.parentElement;
        }

        if (currentSVG && currentSVG.hasAttribute(attr)) {
          return currentSVG.getAttribute(attr);
        }

        const svgStyle = currentSVG ? currentSVG.getAttribute("style") : null;
        if (svgStyle) {
          const styles = parseStyleAttribute(svgStyle);
          if (styles[attr]) {
            return styles[attr];
          }
        }

        return defaultValue || (attr === "fill" ? "black" : "none");
      }

      function parseSVGElements() {
        parsedElements = [];
        gradients = {};

        const linearGradients = currentSVG.querySelectorAll("linearGradient");
        linearGradients.forEach((grad) => {
          const id = grad.getAttribute("id");
          const stops = grad.querySelectorAll("stop");
          if (stops.length >= 2) {
            gradients[id] = {
              x1: parseFloat(grad.getAttribute("x1") || 0),
              y1: parseFloat(grad.getAttribute("y1") || 0),
              x2: parseFloat(grad.getAttribute("x2") || 100),
              y2: parseFloat(grad.getAttribute("y2") || 0),
              color1: stops[0].getAttribute("stop-color") || "black",
              color2:
                stops[stops.length - 1].getAttribute("stop-color") || "white",
            };
          }
        });

        const elements = currentSVG.querySelectorAll(
          "rect, circle, ellipse, line, polyline, polygon, path, text, image",
        );

        elements.forEach((el) => {
          const type = el.tagName.toLowerCase();
          const element = { type, attributes: {} };

          for (let attr of el.attributes) {
            element.attributes[attr.name] = attr.value;
          }

          element.fill = getStyleValue(
            el,
            "fill",
            type === "text" ? "black" : "black",
          );
          element.stroke = getStyleValue(el, "stroke", "none");
          element.strokeWidth = getStyleValue(el, "stroke-width", "1");

          if (type === "text") {
            // Check if text has tspan children
            const tspans = el.querySelectorAll("tspan");

            if (tspans.length > 0) {
              // Process each tspan as a separate text element
              tspans.forEach((tspan) => {
                const tspanElement = {
                  type: "text",
                  attributes: {},
                };

                // Get position from tspan or inherit from parent
                tspanElement.attributes.x =
                  tspan.getAttribute("x") || el.getAttribute("x") || "0";
                tspanElement.attributes.y =
                  tspan.getAttribute("y") || el.getAttribute("y") || "0";

                // Get fill from tspan first, then parent text element
                tspanElement.fill = getStyleValue(
                  tspan,
                  "fill",
                  getStyleValue(el, "fill", "black"),
                );
                tspanElement.stroke = getStyleValue(tspan, "stroke", "none");
                tspanElement.strokeWidth = getStyleValue(
                  tspan,
                  "stroke-width",
                  "1",
                );

                tspanElement.fontSize = getStyleValue(
                  tspan,
                  "font-size",
                  getStyleValue(el, "font-size", "16px"),
                );
                tspanElement.fontFamily = getStyleValue(
                  tspan,
                  "font-family",
                  getStyleValue(el, "font-family", "sans-serif"),
                );
                tspanElement.textContent = tspan.textContent.trim();
                tspanElement.textAnchor = getStyleValue(
                  tspan,
                  "text-anchor",
                  getStyleValue(el, "text-anchor", "start"),
                );
                tspanElement.tftFont = getClosestFont(tspanElement.fontSize);

                parsedElements.push(tspanElement);
              });

              // Don't add the parent text element
              return;
            } else {
              // No tspans, use text element directly
              element.fontSize = getStyleValue(el, "font-size", "16px");
              element.fontFamily = getStyleValue(
                el,
                "font-family",
                "sans-serif",
              );
              element.textContent = el.textContent.trim();
              element.textAnchor = getStyleValue(el, "text-anchor", "start");
              element.tftFont = getClosestFont(element.fontSize);
            }
          }

          if (type === "image") {
            element.href =
              el.getAttribute("href") || el.getAttribute("xlink:href");
          }

          parsedElements.push(element);
        });
      }

      function colorToRGB565(color) {
        if (!color || color === "none" || color === "transparent") return null;

        if (color.startsWith("url(")) {
          const match = color.match(/url\(#(.+)\)/);
          if (match && gradients[match[1]]) {
            return { gradient: match[1] };
          }
          return null;
        }

        const namedColors = {
          black: "TFT_BLACK",
          white: "TFT_WHITE",
          red: "TFT_RED",
          green: "TFT_GREEN",
          blue: "TFT_BLUE",
          cyan: "TFT_CYAN",
          magenta: "TFT_MAGENTA",
          yellow: "TFT_YELLOW",
          orange: "TFT_ORANGE",
          navy: "TFT_NAVY",
          darkgreen: "TFT_DARKGREEN",
          darkcyan: "TFT_DARKCYAN",
          maroon: "TFT_MAROON",
          purple: "TFT_PURPLE",
          olive: "TFT_OLIVE",
          lightgrey: "TFT_LIGHTGREY",
          darkgrey: "TFT_DARKGREY",
          pink: "TFT_PINK",
          greenyellow: "TFT_GREENYELLOW",
          gray: "TFT_DARKGREY",
          grey: "TFT_DARKGREY",
        };

        const lowerColor = color.toLowerCase().trim();
        if (namedColors[lowerColor]) {
          return namedColors[lowerColor];
        }

        let r, g, b;
        if (color.startsWith("#")) {
          const hex = color.substring(1);
          if (hex.length === 3) {
            r = parseInt(hex[0] + hex[0], 16);
            g = parseInt(hex[1] + hex[1], 16);
            b = parseInt(hex[2] + hex[2], 16);
          } else {
            r = parseInt(hex.substring(0, 2), 16);
            g = parseInt(hex.substring(2, 4), 16);
            b = parseInt(hex.substring(4, 6), 16);
          }
        } else if (color.startsWith("rgb")) {
          const matches = color.match(/\d+/g);
          if (matches && matches.length >= 3) {
            [r, g, b] = matches.map(Number);
          } else {
            return "TFT_BLACK";
          }
        } else {
          return "TFT_BLACK";
        }

        const rgb565 = ((r & 0xf8) << 8) | ((g & 0xfc) << 3) | (b >> 3);
        return `0x${rgb565.toString(16).toUpperCase().padStart(4, "0")}`;
      }

      function generateCode() {
        const functionName = "drawSVG" + svgFileName;

        let code = `// Generated by SVG to TFT_eSPI Converter
// Source: ${svgFileName}.svg
// Target screen: ${screenWidth}Ã—${screenHeight}px

#include <TFT_eSPI.h>

TFT_eSPI tft = TFT_eSPI();

void ${functionName}(TFT_eSPI &tft, int16_t x_offset, int16_t y_offset) {
`;

        parsedElements.forEach((el, idx) => {
          code += `  // Element ${idx + 1}: ${el.type}\n`;

          const fillColor = colorToRGB565(el.fill);
          const strokeColor = colorToRGB565(el.stroke);

          switch (el.type) {
            case "rect":
              const x = scaleCoord(parseFloat(el.attributes.x || 0), "x");
              const y = scaleCoord(parseFloat(el.attributes.y || 0), "y");
              const w = scaleCoord(parseFloat(el.attributes.width || 0), "x");
              const h = scaleCoord(parseFloat(el.attributes.height || 0), "y");
              const rx = scaleCoord(parseFloat(el.attributes.rx || 0), "x");

              if (fillColor && fillColor.gradient) {
                const grad = gradients[fillColor.gradient];
                const isVertical =
                  Math.abs(grad.y2 - grad.y1) > Math.abs(grad.x2 - grad.x1);
                const gradFunc = isVertical
                  ? "fillRectVGradient"
                  : "fillRectHGradient";
                code += `  tft.${gradFunc}(x_offset + ${x}, y_offset + ${y}, ${w}, ${h}, ${colorToRGB565(grad.color1)}, ${colorToRGB565(grad.color2)});\n`;
              } else if (fillColor) {
                if (rx > 0) {
                  code += `  tft.fillRoundRect(x_offset + ${x}, y_offset + ${y}, ${w}, ${h}, ${rx}, ${fillColor});\n`;
                } else {
                  code += `  tft.fillRect(x_offset + ${x}, y_offset + ${y}, ${w}, ${h}, ${fillColor});\n`;
                }
              }
              if (strokeColor) {
                if (rx > 0) {
                  code += `  tft.drawRoundRect(x_offset + ${x}, y_offset + ${y}, ${w}, ${h}, ${rx}, ${strokeColor});\n`;
                } else {
                  code += `  tft.drawRect(x_offset + ${x}, y_offset + ${y}, ${w}, ${h}, ${strokeColor});\n`;
                }
              }
              break;

            case "circle":
              const cx = scaleCoord(parseFloat(el.attributes.cx || 0), "x");
              const cy = scaleCoord(parseFloat(el.attributes.cy || 0), "y");
              const r = scaleCoord(parseFloat(el.attributes.r || 0), "x");

              if (fillColor && !fillColor.gradient) {
                code += `  tft.fillCircle(x_offset + ${cx}, y_offset + ${cy}, ${r}, ${fillColor});\n`;
              }
              if (strokeColor) {
                code += `  tft.drawCircle(x_offset + ${cx}, y_offset + ${cy}, ${r}, ${strokeColor});\n`;
              }
              break;

            case "ellipse":
              const ecx = scaleCoord(parseFloat(el.attributes.cx || 0), "x");
              const ecy = scaleCoord(parseFloat(el.attributes.cy || 0), "y");
              const erx = scaleCoord(parseFloat(el.attributes.rx || 0), "x");
              const ery = scaleCoord(parseFloat(el.attributes.ry || 0), "y");

              const avgR = Math.round((erx + ery) / 2);
              if (fillColor && !fillColor.gradient) {
                code += `  // Ellipse approximated as circle\n`;
                code += `  tft.fillCircle(x_offset + ${ecx}, y_offset + ${ecy}, ${avgR}, ${fillColor});\n`;
              }
              if (strokeColor) {
                code += `  tft.drawCircle(x_offset + ${ecx}, y_offset + ${ecy}, ${avgR}, ${strokeColor});\n`;
              }
              break;

            case "line":
              const x1 = scaleCoord(parseFloat(el.attributes.x1 || 0), "x");
              const y1 = scaleCoord(parseFloat(el.attributes.y1 || 0), "y");
              const x2 = scaleCoord(parseFloat(el.attributes.x2 || 0), "x");
              const y2 = scaleCoord(parseFloat(el.attributes.y2 || 0), "y");

              const lineColor = strokeColor || fillColor;
              if (lineColor && !lineColor.gradient) {
                code += `  tft.drawLine(x_offset + ${x1}, y_offset + ${y1}, x_offset + ${x2}, y_offset + ${y2}, ${lineColor});\n`;
              }
              break;

            case "polyline":
            case "polygon":
              const points = el.attributes.points
                .trim()
                .split(/[\s,]+/)
                .map(parseFloat);
              const scaledPoints = points.map((p, i) =>
                scaleCoord(p, i % 2 === 0 ? "x" : "y"),
              );
              const polyColor = strokeColor || fillColor;

              if (scaledPoints.length === 6 && el.type === "polygon") {
                if (fillColor && !fillColor.gradient) {
                  code += `  tft.fillTriangle(x_offset + ${scaledPoints[0]}, y_offset + ${scaledPoints[1]}, x_offset + ${scaledPoints[2]}, y_offset + ${scaledPoints[3]}, x_offset + ${scaledPoints[4]}, y_offset + ${scaledPoints[5]}, ${fillColor});\n`;
                }
                if (strokeColor) {
                  code += `  tft.drawTriangle(x_offset + ${scaledPoints[0]}, y_offset + ${scaledPoints[1]}, x_offset + ${scaledPoints[2]}, y_offset + ${scaledPoints[3]}, x_offset + ${scaledPoints[4]}, y_offset + ${scaledPoints[5]}, ${strokeColor});\n`;
                }
              } else if (
                polyColor &&
                !polyColor.gradient &&
                scaledPoints.length >= 4
              ) {
                for (let i = 0; i < scaledPoints.length - 2; i += 2) {
                  code += `  tft.drawLine(x_offset + ${scaledPoints[i]}, y_offset + ${scaledPoints[i + 1]}, x_offset + ${scaledPoints[i + 2]}, y_offset + ${scaledPoints[i + 3]}, ${polyColor});\n`;
                }
                if (el.type === "polygon" && scaledPoints.length >= 4) {
                  code += `  tft.drawLine(x_offset + ${scaledPoints[scaledPoints.length - 2]}, y_offset + ${scaledPoints[scaledPoints.length - 1]}, x_offset + ${scaledPoints[0]}, y_offset + ${scaledPoints[1]}, ${polyColor});\n`;
                }
              }
              break;

            case "path":
              code += `  // Path drawing (simplified)\n`;
              const d = el.attributes.d;
              if (d) {
                const pathCommands = parsePath(d);
                let currentX = 0,
                  currentY = 0;
                const pathColor = strokeColor || fillColor;

                if (pathColor && !pathColor.gradient) {
                  pathCommands.forEach((cmd) => {
                    if (cmd.type === "M") {
                      currentX = scaleCoord(cmd.x, "x");
                      currentY = scaleCoord(cmd.y, "y");
                    } else if (cmd.type === "L") {
                      const newX = scaleCoord(cmd.x, "x");
                      const newY = scaleCoord(cmd.y, "y");
                      code += `  tft.drawLine(x_offset + ${currentX}, y_offset + ${currentY}, x_offset + ${newX}, y_offset + ${newY}, ${pathColor});\n`;
                      currentX = newX;
                      currentY = newY;
                    }
                  });
                }
              }
              break;

            case "text":
              const tx = scaleCoord(parseFloat(el.attributes.x || 0), "x");
              const ty = scaleCoord(parseFloat(el.attributes.y || 0), "y");
              const text = el.textContent.replace(/"/g, '\\"');

              if (text && fillColor && !fillColor.gradient) {
                code += `  tft.setTextColor(${fillColor});\n`;

                const anchor = el.textAnchor || "start";
                if (anchor === "middle") {
                  code += `  tft.setTextDatum(MC_DATUM);\n`;
                } else if (anchor === "end") {
                  code += `  tft.setTextDatum(MR_DATUM);\n`;
                } else {
                  code += `  tft.setTextDatum(ML_DATUM);\n`;
                }

                code += `  tft.drawString("${text}", x_offset + ${tx}, y_offset + ${ty}, ${el.tftFont}); // ~${FONT_SIZES[el.tftFont]}px\n`;
                code += `  tft.setTextDatum(TL_DATUM);\n`;
              }
              break;

            case "image":
              const ix = scaleCoord(parseFloat(el.attributes.x || 0), "x");
              const iy = scaleCoord(parseFloat(el.attributes.y || 0), "y");
              const iw = scaleCoord(parseFloat(el.attributes.width || 0), "x");
              const ih = scaleCoord(parseFloat(el.attributes.height || 0), "y");

              code += `  // Image: Convert to RGB565 using image2cpp (https://javl.github.io/image2cpp/)\n`;
              code += `  // tft.pushImage(x_offset + ${ix}, y_offset + ${iy}, ${iw}, ${ih}, imageArray);\n`;
              break;
          }

          code += "\n";
        });

        code += `}

void setup() {
  tft.init();
  tft.setRotation(1);
  tft.fillScreen(${backgroundColor});
  
  ${functionName}(tft, 0, 0);
}

void loop() {
  // Add animation or interaction code here
}
`;

        document.getElementById("codeOutput").value = code;
      }

      function parsePath(d) {
        const commands = [];
        const regex = /([MLHVCSQTAZ])([^MLHVCSQTAZ]*)/gi;
        let match;
        let currentX = 0,
          currentY = 0;

        while ((match = regex.exec(d)) !== null) {
          const type = match[1].toUpperCase();
          const isRelative = match[1] === match[1].toLowerCase();
          const params = match[2]
            .trim()
            .split(/[\s,]+/)
            .filter((p) => p)
            .map(parseFloat);

          if (type === "M" && params.length >= 2) {
            currentX = isRelative ? currentX + params[0] : params[0];
            currentY = isRelative ? currentY + params[1] : params[1];
            commands.push({ type: "M", x: currentX, y: currentY });
          } else if (type === "L" && params.length >= 2) {
            currentX = isRelative ? currentX + params[0] : params[0];
            currentY = isRelative ? currentY + params[1] : params[1];
            commands.push({ type: "L", x: currentX, y: currentY });
          } else if (type === "H" && params.length >= 1) {
            currentX = isRelative ? currentX + params[0] : params[0];
            commands.push({ type: "L", x: currentX, y: currentY });
          } else if (type === "V" && params.length >= 1) {
            currentY = isRelative ? currentY + params[0] : params[0];
            commands.push({ type: "L", x: currentX, y: currentY });
          }
        }

        return commands;
      }

      function copyCode() {
        const codeOutput = document.getElementById("codeOutput");
        codeOutput.select();
        document.execCommand("copy");

        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = "âœ“ Copied!";
        setTimeout(() => {
          btn.textContent = originalText;
        }, 2000);
      }

      function downloadSketch() {
        const code = document.getElementById("codeOutput").value;
        const blob = new Blob([code], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = svgFileName + ".ino";
        a.click();
        URL.revokeObjectURL(url);
      }

      function reset() {
        currentSVG = null;
        parsedElements = [];
        gradients = {};
        svgFileName = "";
        backgroundColor = "TFT_BLACK";
        scaleX = 1;
        scaleY = 1;
        screenWidth = 0;
        screenHeight = 0;
        document.getElementById("codeOutput").value = "";
        fileInput.value = "";
        document.getElementById("uploadPanel").classList.remove("hidden");
        document.getElementById("outputPanel").classList.add("hidden");
      }
    </script>
  </body>
</html>
